import glob
import pandas as pd
import pickle
import numpy as np
import sys
import json
import os
from collections import OrderedDict
total = 0
peSectionsTexts = ''
fileText = ''

########################## STATIC MODEL ##########################
####### Feature Extraction #######

def encodeStatic(string):  # Encoder
    sum = 0
    for i in range(len(string)):
        sum += (ord(str(string[i])))
    return sum

def getPEHeaders(): # Extract PE Headers from the file
    global peSectionsTexts, fileText
    toRemove = []
    peFeatures = fileText.split('----------PE Sections----------')
    peFeatures = peFeatures[1].split('----------Directories----------')[0]
    peSectionsTexts = peFeatures.split('[IMAGE_SECTION_HEADER]')
    for i in range(len(peSectionsTexts)):
        peSectionsTexts[i] = peSectionsTexts[i].strip()
        if peSectionsTexts[i] in [' ','']:
            toRemove.append(i)
    for element in toRemove:
        peSectionsTexts.pop(element)
    toRemove = []
    for i in range(len(peSectionsTexts)):
        peSectionsTexts[i] = peSectionsTexts[i].split('\n')
        for j in range(len(peSectionsTexts[i])):
            peSectionsTexts[i][j] = peSectionsTexts[i][j].split(':')
            try:
                peSectionsTexts[i][j][-1] = str(int(peSectionsTexts[i][j][-1] ,16))
            except ValueError:
                peSectionsTexts[i][j][-1] = str(encodeStatic(peSectionsTexts[i][j][-1]))
        peSectionsTexts[i].pop(-1)
        peSectionsTexts[i].pop(-1)
        peSectionsTexts[i].pop(-1)
        peSectionsTexts[i].pop(-1)
        peSectionsTexts[i].pop(-2)

def getPEFileHeader(): # Extract PE File Headers from the file
    global peFileTexts, fileText
    toRemove = []
    peFileFeatures = fileText.split('----------FILE_HEADER----------')
    peFileFeatures = peFileFeatures[1].split('----------OPTIONAL_HEADER----------')[0]
    peFileTexts = peFileFeatures.split('[IMAGE_FILE_HEADER]')
    for i in range(len(peFileTexts)):
        peFileTexts[i] = peFileTexts[i].strip()
        if peFileTexts[i] in [' ','']:
            toRemove.append(i)
    for element in toRemove:
        peFileTexts.pop(element)
    toRemove = []
    for i in range(len(peFileTexts)):
        peFileTexts[i] = peFileTexts[i].split('\n')
        for j in range(len(peFileTexts[i])):
            peFileTexts[i][j] = peFileTexts[i][j].split()
            if len(peFileTexts[i][j]) == 4 and peFileTexts[i][j][0] not in ['Flags:', 'Entropy:']:
                peFileTexts[i][j].pop(0)
                peFileTexts[i][j].pop(0)
                try:
                    peFileTexts[i][j][-1] = str(int(peFileTexts[i][j][-1] ,16))
                except ValueError:
                    peFileTexts[i][j][-1] = str(encodeStatic(peFileTexts[i][j][-1]))
            peFileTexts[i][j][0] = peFileTexts[i][j][0].split(':')[0]
        peFileTexts[i].pop(-1)
        peFileTexts[i].pop(2)

def getOptionalHeader(): # Extract PE Optional Headers from the file
    global optionalFileText, fileText
    toRemove = []
    optionalFileFeatures = fileText.split('----------OPTIONAL_HEADER----------')
    optionalFileFeatures = optionalFileFeatures[1].split('----------PE Sections----------')[0]
    optionalFileText = optionalFileFeatures.split('[IMAGE_OPTIONAL_HEADER]')
    for i in range(len(optionalFileText)):
        optionalFileText[i] = optionalFileText[i].strip()
        if optionalFileText[i] in [' ','']:
            toRemove.append(i)
    for element in toRemove:
        optionalFileText.pop(element)
    toRemove = []
    for i in range(len(optionalFileText)):
        optionalFileText[i] = optionalFileText[i].split('\n')
        for j in range(len(optionalFileText[i])):
            optionalFileText[i][j] = optionalFileText[i][j].split()
            if len(optionalFileText[i][j]) == 4 and optionalFileText[i][j][0] not in ['Flags:', 'Entropy:']:
                optionalFileText[i][j].pop(0)
                optionalFileText[i][j].pop(0)
                try:
                    optionalFileText[i][j][-1] = str(int(optionalFileText[i][j][-1] ,16))
                except ValueError:
                    optionalFileText[i][j][-1] = str(encodeStatic(optionalFileText[i][j][-1]))
            optionalFileText[i][j][0] = optionalFileText[i][j][0].split(':')[0]
        optionalFileText[i].pop(-1)

####### Feature Extraction #######
def executeStaticAnalysis(): # Extract static analysis
    global total, sectionCounter, peSectionsDict, hashName, fileText, peFileTexts, finalOut
    total += 1
    fileName = os.path.join(filepath, 'Structure_Info.txt')
    f = open(fileName, 'r', errors='replace')
    hashName =os.path.basename(filepath)
    fileText = f.read()
    getPEHeaders()
    getPEFileHeader()
    getOptionalHeader()
    finalOut.write(hashName + ',')
    count = 1
    for section in peFileTexts:
        for item in section:
            finalOut.write(item[-1] + ',')
            count += 1
    for section in optionalFileText:
        for item in section:
            finalOut.write(item[-1] + ',')
            count += 1
    for section in peSectionsTexts:
        for item in section:
            if count > 83:
                break
            finalOut.write(item[-1] + ',')
            count += 1
        if count >83:
            break
    while count <84:
        finalOut.write(',-1') #PAD with -1 if feature doesnt exist
        count += 1
    finalOut.write('\n')
    f.close()

####### Generate Feature File #######
inputArg = sys.argv[1]
rootDir = os.path.dirname(inputArg)
staticBenign = os.path.join(rootDir, 'Static_Analysis_Data/*/*')
staticMalware = os.path.join(rootDir, 'Static_Analysis_Data/*/*/*')

paths = [staticBenign, staticMalware]
finalOut = open('tempStatic.csv', 'w')
counter = 0
for path in paths:
    for filepath in glob.iglob(path):
        if os.path.isdir(filepath):
            counter += 1
            try:
                executeStaticAnalysis()
            except:
                continue
finalOut.close()

####### Load data #######

#Load static data into dataframe 
dataset = pd.read_csv('tempStatic.csv')
X = dataset.iloc[:, 1:83].values
labels = dataset.iloc[:,0].values

#Load static data through imputer to replace all of the nan values
fileName = 'imputer.sav'
imputer = pickle.load(open(fileName, 'rb'))
X = imputer.transform(X)

#Feature scaling to normalize entries
fileName = 'scalerStatic.sav'
sc = pickle.load(open(fileName, 'rb'))
X = sc.transform(X)

#Feature reduction to reduce dimensionality
fileName = 'pcaStatic.sav'
pca = pickle.load(open(fileName, 'rb'))
X = pca.transform(X)

#Random Forest model
fileName = 'staticAnalysisRandomForest.sav'
loaded_model = pickle.load(open(fileName, 'rb'))
result = loaded_model.predict(X)
print(result)

########################## DYNAMIC MODEL ##########################

piCalls = {'GlobalMemoryStatusEx', 'OleInitialize', 'GetDiskFreeSpaceW', 'OutputDebugStringA', 'InternetConnectW', 'RegEnumKeyExA', 'CryptDecrypt', 'NtCreateUserProcess', 'CryptEncrypt', 'WSASendTo', 'NtLoadDriver', 'RtlAddVectoredContinueHandler', 'NetUserGetLocalGroups', 'InternetGetConnectedStateExW', 'NtQueryAttributesFile', 'StartServiceW', 'NtCreateThreadEx', 'NtSetValueKey', 'SHGetFolderPathW', 'OpenSCManagerW', 'DeleteUrlCacheEntryA', 'NtDuplicateObject', 'WriteConsoleW', 'CertCreateCertificateContext', 'CoUninitialize', 'NtCreateSection', 'NetUserGetInfo', 'WSAConnect', 'GetDiskFreeSpaceExW', 'CryptUnprotectData', 'CryptGenKey', 'recvfrom', 'NtLoadKey', 'HttpSendRequestA', 'InternetConnectA', 'GetKeyboardState', 'LoadStringW', 'select', 'NtQueryInformationFile', 'GetFileInformationByHandle', 'CreateServiceA', 'NtOpenThread', 'Thread32Next', 'NtQueryDirectoryFile', 'getaddrinfo', 'socket', 'PRF', 'RemoveDirectoryW', 'SendNotifyMessageW', 'NtReadVirtualMemory', 'GetFileAttributesExW', 'accept', 'CryptDecodeObjectEx', 'CoGetClassObject', 'send', 'GetKeyState', 'WSASend', 'NtQueryKey', 'HttpQueryInfoA', 'FindWindowA', 'CreateRemoteThreadEx', 'NtOpenProcess', 'IWbemServices_ExecQuery', 'CryptAcquireContextA', 'NtUnloadDriver', 'Thread32First', 'SetFileTime', 'HttpSendRequestW', 'MessageBoxTimeoutA', 'RegCloseKey', 'DeviceIoControl', 'Module32NextW', 'NtQuerySystemInformation', 'CreateDirectoryW', 'GetSystemDirectoryA', 'RegCreateKeyExA', 'CryptAcquireContextW', 'CreateJobObjectW', 'InternetOpenUrlA', 'GetTempPathW', 'InternetGetConnectedStateExA', 'LdrLoadDll', 'InternetOpenUrlW', 'NetShareEnum', 'SetWindowsHookExW', 'CertOpenStore', 'SetFileAttributesW', 'SearchPathW', 'SetErrorMode', 'gethostbyname', 'CertControlStore', 'NtFreeVirtualMemory', 'NtCreateKey', 'IsDebuggerPresent', 'OpenServiceW', 'RegisterHotKey', 'RegQueryValueExW', 'CreateRemoteThread', 'CopyFileA', 'InternetCrackUrlW', 'NtWriteVirtualMemory', '__exception__', 'Process32FirstW', 'setsockopt', 'RegDeleteValueA', 'ExitWindowsEx', 'InternetOpenA', 'WNetGetProviderNameW', 'NtProtectVirtualMemory', 'RtlAddVectoredExceptionHandler', 'HttpOpenRequestA', 'ReadProcessMemory', 'CoInitializeSecurity', 'NtDeleteFile', 'DnsQuery_W', 'RegCreateKeyExW', 'InternetCloseHandle', 'CryptUnprotectMemory', 'NtDeleteValueKey', 'UuidCreate', 'SetEndOfFile', 'NtCreateDirectoryObject', 'GetSystemInfo', 'CoCreateInstanceEx', 'OpenServiceA', 'TaskDialog', 'listen', 'RegDeleteKeyW', 'NtMapViewOfSection', 'LookupAccountSidW', 'GetComputerNameA', 'LdrUnloadDll', 'recv', 'NtGetContextThread', 'DrawTextExA', 'RegSetValueExA', 'closesocket', 'NtDeleteKey', 'GetUserNameExW', 'GetUserNameW', 'GetFileAttributesW', 'UnhookWindowsHookEx', 'NtClose', 'GetAdaptersAddresses', 'RtlRemoveVectoredExceptionHandler', 'GetVolumePathNamesForVolumeNameW', 'NtSetContextThread', 'RegQueryInfoKeyW', 'GetForegroundWindow', 'CryptHashData', 'ioctlsocket', '_anomaly', 'CreateServiceW', 'NtSetInformationFile', 'WSASocketW', 'NtSaveKeyEx', 'InternetSetOptionA', 'RegOpenKeyExA', 'NtEnumerateValueKey', 'GlobalMemoryStatus', 'GetNativeSystemInfo', 'CreateActCtxW', 'GetFileType', 'SetFilePointerEx', 'NtReadFile', 'NtQueryValueKey', 'CertOpenSystemStoreW', 'GetAdaptersInfo', 'EnumServicesStatusA', 'CryptCreateHash', 'DnsQuery_A', 'GetSystemDirectoryW', 'NtTerminateThread', 'NtResumeThread', 'RegQueryInfoKeyA', 'NtSuspendThread', 'GetFileInformationByHandleEx', 'NtDelayExecution', 'NtOpenMutant', 'InternetWriteFile', 'NtWriteFile', 'NtOpenSection', 'GetVolumeNameForVolumeMountPointW', 'IWbemServices_ExecMethod', 'NtQueryMultipleValueKey', 'LookupPrivilegeValueW', 'NtOpenKeyEx', 'GetSystemWindowsDirectoryA', 'SetStdHandle', 'NtOpenKey', 'HttpOpenRequestW', 'InternetOpenW', 'NtQueryFullAttributesFile', 'FindResourceW', 'SetUnhandledExceptionFilter', 'NtEnumerateKey', 'AssignProcessToJobObject', 'MessageBoxTimeoutW', 'NtCreateFile', 'WSASocketA', 'connect', 'NetGetJoinInformation', 'bind', 'NtCreateMutant', 'CopyFileExW', 'CopyFileW', 'NtQueueApcThread', 'InternetQueryOptionA', 'GetInterfaceInfo', 'DeleteUrlCacheEntryW', 'StartServiceA', 'RegEnumKeyExW', 'NtOpenDirectoryObject', 'LoadResource', 'URLDownloadToFileW', 'SHGetSpecialFolderLocation', 'GetSystemTimeAsFileTime', 'CryptProtectMemory', 'GetSystemMetrics', 'OpenSCManagerA', 'InternetReadFile', 'GetFileSizeEx', 'FindResourceExW', 'GetVolumePathNameW', 'GetBestInterfaceEx', 'SetInformationJobObject', 'NtUnmapViewOfSection', 'NtAllocateVirtualMemory', 'FindWindowExW', 'RegEnumValueW', 'ReadCabinetState', 'RtlCreateUserThread', 'DeleteFileW', 'LdrGetProcedureAddress', 'RegOpenKeyExW', 'GetShortPathNameW', 'CryptProtectData', 'SetFilePointer', 'NtOpenFile', 'SizeofResource', 'RegDeleteKeyA', 'LoadStringA', 'DeleteService', 'DecryptMessage', 'GetFileVersionInfoSizeW', 'EnumServicesStatusW', 'RtlCompressBuffer', 'GetFileSize', 'getsockname', 'NtDeviceIoControlFile', 'MoveFileWithProgressW', 'WriteConsoleA', 'NtShutdownSystem', 'RegDeleteValueW', 'CreateThread', 'FindFirstFileExA', 'GetFileVersionInfoExW', 'InternetGetConnectedState', 'InternetCrackUrlA', 'RtlDecompressBuffer', 'GetCursorPos', 'GetAsyncKeyState', 'FindWindowExA', 'SendNotifyMessageA', 'FindWindowW', 'EnumWindows', 'GetSystemWindowsDirectoryW', 'NtTerminateProcess', 'CertOpenSystemStoreA', 'SetFileInformationByHandle', 'DrawTextExW', 'WriteProcessMemory', 'RegEnumValueA', 'ShellExecuteExW', 'GetAddrInfoW', 'timeGetTime', 'FindResourceA', 'WSARecv', 'InternetSetStatusCallback', 'exception_', 'CoInitializeEx', 'GetComputerNameW', 'CryptExportKey', 'SetWindowsHookExA', 'sendto', 'RegQueryValueExA', 'LdrGetDllHandle', 'RegEnumKeyW', 'ControlService', 'GetUserNameA', 'Process32NextW', 'FindFirstFileExW', 'FindResourceExA', 'shutdown', 'RemoveDirectoryA', 'RegSetValueExW', 'CoCreateInstance', 'ObtainUserAgentString', 'CryptHashMessage', 'WSAStartup', 'WSARecvFrom', 'WSAAccept', 'GetUserNameExA', 'EncryptMessage', 'CreateToolhelp32Snapshot', 'CreateDirectoryExW', 'CreateProcessInternalW', 'system', 'Module32FirstW', 'GetFileVersionInfoSizeExW', 'GetFileVersionInfoW', 'GetTimeZoneInformation'}
apiCallsEncoded = [222, 621, 625, 653, 1596, 1614, 1628, 1637, 1640, 1648, 2016, 2066, 2199, 2256, 3060, 3066, 3125, 3378, 3492, 3554, 3614, 3617, 3689, 4263, 4397, 4399, 4432, 4461, 4492, 4587, 4598, 4611, 4630, 4751, 4791, 4851, 4976, 5320, 5360, 5387, 5393, 5446, 5467, 5485, 5496, 5510, 5528, 5530, 5540, 5550, 5557, 5603, 5606, 5611, 5613, 5614, 5638, 5683, 5687, 5707, 5796, 5851, 5938, 5948, 6013, 6188, 6265, 6364, 6447, 6488, 6507, 6580, 6583, 6588, 6591, 6628, 6687, 6689, 6699, 6756, 6785, 6861, 6968, 7022, 7046, 7192, 7251, 7308, 7369, 7405, 7477, 7481, 7604, 7607, 7633, 7669, 7705, 7709, 7714, 7737, 7741, 7757, 7768, 7837, 7868, 7871, 7969, 7973, 7975, 8001, 8032, 8119, 8127, 8166, 8196, 8213, 8219, 8276, 8277, 8385, 8559, 8594, 8614, 8688, 8706, 8845, 8880, 8951, 8992, 9021, 9193, 9237, 9312, 9411, 9424, 9441, 9497, 9529, 9538, 9572, 9589, 9608, 9649, 9689, 9748, 9985, 10099, 10240, 10286, 10293, 10399, 10548, 10556, 10594, 10619, 10752, 10867, 10884, 10966, 11002, 11479, 11746, 11751, 11809, 11819, 11866, 11915, 11918, 11936, 11973, 11989, 12012, 12076, 12081, 12149, 12165, 12169, 12216, 12224, 12239, 12248, 12276, 12301, 12325, 12338, 12342, 12370, 12374, 12439, 12499, 12554, 12619, 12672, 12739, 12788, 12822, 13059, 13306, 13335, 13398, 13496, 13687, 13750, 13769, 13922, 13941, 13945, 14208, 14385, 14513, 15005, 15164, 15204, 15375, 15435, 15501, 15518, 15523, 15578, 15640, 15716, 15748, 15815, 15832, 15856, 15875, 15986, 16205, 16362, 16429, 16492, 16624, 17104, 17362, 17369, 17413, 17593, 17623, 17666, 17671, 17839, 17868, 17985, 18019, 18067, 18153, 18189, 18255, 18807, 19074, 19162, 19225, 19406, 19493, 19504, 19550, 19588, 19603, 19784, 19824, 19922, 20005, 20014, 20296, 20478, 20482, 21065, 21296, 21508, 21832, 21838, 21868, 21876, 21879, 22142, 23881, 23952, 23953, 24393, 24679, 25179, 25767, 25829, 26239, 26268, 26292, 26853, 27750, 27903, 28062, 29527, 30219, 30721, 30856, 31145, 32997, 33394, 33846, 34396, 36571, 37456, 38031, 38050, 39567, 41820, 44884, 49890, 54650, 54703]
frequencyDict = OrderedDict.fromkeys(apiCallsEncoded, 0)
####### Encode strings to integers #######
def encodeDynamic(string):
    sum = 0
    for i in range(len(string)):
        sum += ord(string[i])*i
    return sum


inputArg = sys.argv[1]
rootDir = os.path.dirname(inputArg)
dynamicBenignPath = os.path.join(rootDir, 'Dynamic_Analysis_Data/*/*')
dynamicMalwarePath = os.path.join(rootDir, 'Dynamic_Analysis_Data/*/*/*')

paths = [ dynamicBenignPath, dynamicMalwarePath]
opFile = open('tempDynamic.csv','w')
total = 0
####### Load data #######
for path in paths:
    for filepath in sorted(glob.iglob(path)):
        if os.path.isfile(filepath):
            total += 1
            file = open(filepath,'r')
            hashName =os.path.basename(filepath).split('.')[0]
            opFile.write(hashName + ',')
            jsonData = json.loads(file.read())
            callCountTemp = jsonData['behavior']['apistats']
            callCount = frequencyDict
            for item in callCountTemp:
                for key in callCountTemp[item]:
                    callCount[encodeDynamic(key)] =0
                    callCount[encodeDynamic(key)] += int(callCountTemp[item][key])
            for item in frequencyDict:
                opFile.write(str(frequencyDict[item]) + ',')
            frequencyDict = dict.fromkeys(apiCallsEncoded, 0)
            if path == dynamicBenignPath:
                opFile.write('1\n')
            else:
                opFile.write('0\n')
opFile.close()

# Load data into dataframe
dataset = pd.read_csv('tempDynamic.csv')
X = dataset.iloc[:, 1:-2].values
labels1 = dataset.iloc[:,0].values

#RandomForest Predict
fileName = 'dynamicAnalysisRandomForest.sav'
loaded_model = pickle.load(open(fileName, 'rb'))
result1 = loaded_model.predict(X)
print(result1)

#Write into final file
finalFile = open('prediction.csv','w')
for i in range(len(labels)):
    finalFile.write(str(labels[i]) + ',' + str(result[i])+'\n' )
for i in range(len(labels1)):
    finalFile.write(str(labels1[i]) + ',' + str(result1[i])+'\n' )
finalFile.close()